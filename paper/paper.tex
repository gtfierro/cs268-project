\documentclass[conference]{IEEEtran}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{url}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[labelfont=bf,format=plain,font=small]{subcaption}
\usepackage[labelfont=bf,format=plain,font=small]{caption}
\usepackage{array}
\newcolumntype{L}{>{\arraybackslash}m{3cm}}
\usepackage{minted}
\newminted{sql}{mathescape, numbersep=5pt, frame=lines, framesep=2mm, fontsize=\footnotesize}
\usepackage{MnSymbol}
\def\prebreak{\raisebox{0ex}[0ex][0ex]{\ensuremath{\rhookswarrow}}}
\def\postbreak{\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookrightarrow\space}}}
\def\lstbreak{\prebreak\newline\postbreak}
\lstdefinelanguage{pseudocode}{sensitive=false,morecomment=[l]{//},morestring=[b]",
                               morekeywords={if,else,while,continue,true}}
\lstset{breaklines=true,breakindent=5pt,
        postbreak=\postbreak,prebreak=\prebreak}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}\PackageWarning{TODO:}{#1!}}


\begin{document}

\title{CS268 Project}

\author{\IEEEauthorblockN{Gabriel Fierro}
\IEEEauthorblockA{gt.fierro@berkeley.edu}
\and
\IEEEauthorblockN{Zain Amro}
\IEEEauthorblockA{zamro@berkeley.edu}
}

\maketitle

\begin{abstract}
TODO
\end{abstract}

\input{introduction}

\section{Context and Motivation}
\if 0
- Motivation starts off by saying: look, for the very common case of indoor, low-power
  sensor networks, there is a need for routing.
- what do WSN nodes look like?
    - http://www.airccse.org/journal/ijcses/papers/1110ijcses06.pdf
    - low bandwidth, low power, low memory, short range (10-50m)
    - unreliable -- things crash, run out of power -> topology changes!
      - need to adapt to failures
    - self-configuring: nodes will need to discover the topology.
    - channel utilization:
      - want to make efficient use of bandwidth by reducing control traffic
        necessary for maintaining the mesh
      - has upshot of saving power too
      - this is also addressed at MAC layer, which we do not address
- This particular case of WSN topology formation is defined by the following characteristics:
    - SMALL: order 10s of nodes, over a small geographic area: a building or collection of rooms
    - mains power available at some locations throughout a space: wall plugs here and there
    - It is feasible to cover the monitored space in a mesh with hops no greater than 3
    - environment can change: furniture, people -- transient connectivity
- establish the goals and parameters of our proposed routing protocol
- Firstly, what does a routing protocol have to do?
    - mote must discover the prefix
      - simplifying assumptions: slaac, using 48-bit MAC and 16 bit node id
    - build upward routes: multipoint-to-point
      - list some ways to do this?
    - build downward routes
      - need for acknowledgements, actuations
    - point to point routes
      - rarer, but in small networks w/ actuators and sensors, this may become more common.
    - prepare for failure:
      - provide a means of repairing the network
    - useful parts: border router, providing physical translation in/out of
      the network. Handles prefix compression/expansion for 6lowpan, generally
      more powerful, powered. Can have large bandwidth backbone
\fi

\section{RPL -- Gabe }

\if 0
In this section, we need to establish what RPL is, a little tiny bit of its history, and then
go into its design, how it addresses the requirements above, and how well we can predict
these might fit into our chosen scenario.

What is RPL:
  - distance-vector routing protocol designed for low-power and lossy networks, a class of
    network in which both the routers and the interconnects are constrained
  - aims to provide all three traffic patterns: up, down. point-to-point:
    - contrast to CTP which only does collection (up)
  - "RPL does not rely on any particular features of a specific link-layer technology" -RFC6550
  - means that it cannot make assumptions about those features, meaning it can lead to
    redundant design decisions
  - here we concentrate on the application of RPL to low-power, lossy, short-range wireless
    sensor networks
  - brings with it following opportunities and constraints
    - harness the broadcast medium
    - be aware of bandwidth usage, talking too much
    - specifically, "repair" mechanisms can cause a lot of traffic and end up bringing down
      other nodes because now they are overloaded

How do it work though:
- topology:
  - RPL instance = set of 1+ DODAGs sharing RPLinstance ID:
    - each operate independently, implements different objective function
  - DODAGs identify roots. uniquely identified by combination of RPL instance ID
  - rank: defines nodes individual position relative to other nodes w/ respect to the
    DODAG root. Increases farther away from root
  - DODAG root: usually the border router, configures parameters, determines when global
    repair happens
- control mesages
- how topology formation works

We can then start criticizing it:
- complexity:
  - multiple DODAGs, RPL instances, OFs
  - secure version of all headers -- not clear this could be achieved using app level
    or L2 security. To knowledge no one has implemented this
- underspecification:
  - how often to send DAO messages? relayed to the parent, constant overhead of messages
  - interoperability is a problem (contiki/tinyrpl happy together). Two implementations
    must have the same feature set, which is different than the minimal set of features
    required to have the system working:
    - storing mode vs non storing mode
- unnecessary features:
  - RPL instances -- the standard does not even talk about multiple
  - multiple objective functions: only 2 were ever implemented
  - dio/dis are very similar to ipv6 nd ra/rs messages
\fi

\subsection{IPv6 Neighbor Discovery -- Gabe }
\if 0
- RPL is not the only standard that would need to be revisited for wireless LLNs.
- IPv6 Neighbor Discovery is intended to provide following features:
    - router discovery: find routers on attached link
    - parameter discovery:
        - prefix discovery, link MTU, hop limit, etc
    - stateless address autoconfiguration
    - address resolution
    - neighbor unreachability detection (NUD)
    - duplicate address detection
- these are more features than are needed for WSNs because of restrictions:
    - NUD: no need to maintain connectivity to neighbors
        - use the application traffic to determine if link is still good
        - if you don't use the link, don't waste time and energy keeping it up:
            - places pressure on the channel because you can only broadcast!
        - IP is best-effort: use this leeway!
    - duplicate address detection:
        - a common way of configuring motes is SLAAC
        - one way of doing this is 64-bit prefix + 64-bit EUI-64 address
        - 48bit MAC, last 16 bits are a unique node identifier
        - upshot: can compress the address of a mote into 2 bytes (2^16-1 addresses)
        - guaranteed unique address: no need to check for dups
- too chatty:
    - rfc6775 attempts to adapt for 6LowPANs:
    - "Minimize signaling by avoiding the use of multicast
      flooding and reducing the use of link-scope multicast messages"
    - original constants: cite them
    - rfc6775 new constants:
        - max RAs: 3
        - min delay btwn RA: 10s
        - max RA delay time 2 sec
        - RS interval: 10s
        - max RS : 3
        - max Rs interval - 60s
    - TODO: go through NUD params in 4861 and 6775
\fi

\section{Prior Work -- Zain}
\if 0
- in thesis: list of improvements to RPL
- in literature:
    - have other people done small diameter WSN routing?
    - other simple routing protocols for similar situations
\fi

\input{3hop}

\section{Evaluation Platform -- Gabe }
\if 0
- establish the measurement apparatus for these:
    - TinyOS Kernel
    - Syscalls in Lua
        - challenges developing syscalls
    - Dynamic code loading in Lua
    - fitting everything into the mote
    - "WAX stack"
        - follow similar structure to the sensys paper
        - the components of a network experiment code
        - how to we do logging, where it goes
\fi

\section{Evaluation}

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,references}

\end{document}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
